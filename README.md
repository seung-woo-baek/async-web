# 비동기 통신 웹 구현
로그인, 유저 관리, 문의 게시판 등의 기능을 비동기 통신을 통해 구현하는 실습

2021년 12월 20일 작업 내용:
- 로그인 창 마크업 완료
- 회원가입 창 마크업 완료
- 회원가입 입력값 유효성 검사 기능 구현

2021년 12월 21일 작업 내용:
- 회원가입 정보 로컬 스토리지 입력 기능 구현
- 유저 아이디 중복 검사 기능 추가
- 로그인 유효성 검사 기능 구현
- css 수정

2021년 12월 22일 작업 내용:
- 로그인, 회원가입, 회원정보 수정 및 삭제 API 요청
- 공지사항 게시판 마크업 추가
- 공지사항 게시판 목록 기능 구현 (pagination 제외)
- 공지사항 게시판 내용 기능 일부 구현

2021년 12월 23일 작업 내용:
- 공지사항 게시글 목록 기능 오류 수정 : id값을 동일한 값만 파라미터로 넘기는 오류 수정
- 공지사항 게시판 내용 보기 기능 구현 완료
- 공지사항 게시판 글쓰기 기능 일부 구현 : API를 이용한 통신은 API가 개발완료된 후 할 예정
- 회원 정보 퍼블리싱 일부 구현

2021년 12월 24일, 27일 작업 내용:
- 공지사항 게시글 리스트 데이터 구현시 깜빡임을 방지하기 위해 미리 리스트를 마크업 해두고 그 안에 데이터를 넣는 방식으로 변경(이전에는 마크업과 함께 데이터를 함께 띄움)
- 등록된 공지사항이 없을 경우 등록된 공지사항이 없다는 화면이 나오도록 구현
- 게시글 내용 css 일부 수정
- 동기, 비동기의 정확한 차이 학습

------------

## 추가 및 수정 계획
- 로그인 정보 기억하기 : 로컬 스토리지 이용
- 로그인 정보 세션 관리 : 세션 스토리지 이용

------------
## 새로 알게 된 내용
1. fetch()
- fetch()가 리턴하는 Promise 객체는 HTTP error 상태를 reject하지 않는다. 대신 ok 상태가 false인 resolve가 반환된다.
- 네트워크 장애나 요청이 완료되지 못한 상태에는 reject가 반환된다.
2. CORS
- Cross-Origin Resource Sharing
- 다른 출처간에 리소스를 공유할 수 있도록 하는 것
- 백엔드에서 요청을 허락할 다른 출처들을 명시함으로서 해결 가능
3. SOP
- Same Origin Policy
- 대부분의 웹 브라우저가 준수하는 보안 정책
- 다른 Origin에 요청한 것을 기본적으로 제한해서 어느정도 해커의 공격을 방어하는 것
4. HTTPS Status Code
- 200 : OK, 정상적으로 처리됐을 경우 발생
- 201 : Created, 정상적으로 처리되었고 새로운 리소스가 생겼을 경우 발생
- 202 : Accepted, 요청은 정상적이지만, 서버가 아직 요청을 완료하지 못한 경우 발생
- 204 : No Content, 요청은 정상적이지만, 컨텐츠를 제공하지 않는 경우 발생
- 400 : Bad Request요청이 유효하지 않아 더 이상 작업을 진행하지 않는 경우 발생
- 401 : Unauthorized, 인증이 안되어 있을 경우 발생
- 403 : Forbidden, 권한이 없을 경우 발생
- 404 : Not Found, 경로나 자원이 존재하지 않을 경우 발생
- 405 : Method Not Allowed, 허용되지 않는 메소드가 사용된 경우 발생
- 409 : Conflict, 해당 요청의 처리 중 비지니스 로직상 불가능하거나 모순이 생긴 경우 발생
- 429 : Too Many Requests, 클라이언트가 일정 시간 동안 너무 많은 요청을 보낸 경우, 비정상적인 방법으로 자원을 요청하는 경우 발생
- 500 : Server errors, 서버 오류로 인해 발생
5. 인증
- Authentication
- 로그인

## 막혔던 내용 정리
1. GET방식으로 데이터를 보내는 과정 : 
- 현재 게시판 쓰기 API는 GET 방식으로 진행되어 파라미터로 데이터가 전달이 된다. 
- GET방식은 256바이트 이상을 넘길 수 없다고 알려져 있는데 원칙적으로는 제한이 없지만 구형 장비들 중 일부가 256바이트의 주소값을 지원하기 때문에 주의해야한다는 것.
- 약 2000자 정도 이하로 만들어야 모든 브라우저에서 작동
- 한글은 n바이트라는 개념을 통해 한글 한 자를 치기 위해 필요한 타수로 바이트를 계산
- 웹 문서에서 사용되는 다국어 인코딩, 즉 UTF-8 유니코드에서는 한글이나 한자는 3바이트
- URI가 서버가 처리 할 수 있는 거보다 길면 서버는 414 에러를 반환해야한다.
- Lorem Ipsum의 500단어, 3307바이트를 데이터로 넣었을 때 404 에러 발생


- CORS 같은 경우에는 해더값에 Access-Control-Allow-Origin을 추가해 해결이 가능하나, 여전히 길이가 긴 데이터를 보낼 경우 같은 에러가 발생
- lorem ipsum을 통해 다양한 길이의 데이터를 넣어보았고 1484바이트 이상의 데이터 부터는 404 에러를 받는다.
- utf-8의 1글자는 1~4바이트까지 가변적이다.
- 서버의 용량 제한이 있지 않은가 생각 중

2. textarea value를 그대로 저장하게 되면 엔터 처리가 무시된 한줄의 입력값을 받는다.
- '\n'(줄 바꿈) 혹은 '\r\n'(커서를 맨 앞으로 이동시킨 뒤 줄바꿈)인 경우에 br 태그로 처리한다.
    let contentValue = form.notice_write_content.value;
    contentValue = contentValue.replace(/(\n:\r\n)/g, 'br태그')
- br태그가 입력되지만 넘겨지지 않는다.
- innerText로 보여지던 글을 innerHTML로 변경해 해결
